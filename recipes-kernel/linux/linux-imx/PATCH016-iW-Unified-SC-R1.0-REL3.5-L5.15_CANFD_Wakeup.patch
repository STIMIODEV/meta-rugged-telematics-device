diff -Naur A/arch/arm/mach-imx/mach-iwg26i.c B/arch/arm/mach-imx/mach-iwg26i.c
--- A/arch/arm/mach-imx/mach-iwg26i.c	2023-07-14 14:50:06.760977844 +0530
+++ B/arch/arm/mach-imx/mach-iwg26i.c	2023-07-14 14:57:38.188977589 +0530
@@ -213,7 +213,7 @@
 	printk ("\n");
 	printk ("Board Info :\n");
 	printk ("\tBSP Version : %s\n", BSP_VERSION);
-	printk ("\tDevice Name and Release : iW-Unified-SC-01-R3.0-REL3.4-Linux5.15\n");
+	printk ("\tDevice Name and Release : iW-Unified-SC-01-R3.0-REL3.5-Linux5.15\n");
 	printk ("\tCPU Unique ID\t: 0x%08x%08x \n", unique_id2, unique_id1);
 	printk ("\n");
 
diff -Naur A/drivers/net/can/m_can/m_can.c B/drivers/net/can/m_can/m_can.c
--- A/drivers/net/can/m_can/m_can.c	2023-07-14 14:50:07.760977844 +0530
+++ B/drivers/net/can/m_can/m_can.c	2023-07-14 14:53:31.680977728 +0530
@@ -24,7 +24,22 @@
 
 #include "m_can.h"
 bool iw_mcan_prop = false; /* Flag added for Rugged Telematics Device */
+int iw_ie_reg = 0;
 bool mode = false;         /* Flag added for determining when tcan has to go to standby mode */
+#if 0
+int m_can_rx_clear(struct net_device *dev)
+{
+        struct m_can_classdev *cdev = netdev_priv(dev);
+        m_can_disable_all_interrupts(cdev);
+        m_can_rx_peripheral(dev);
+
+        return 0;
+}
+EXPORT_SYMBOL_GPL(m_can_rx_clear);
+#endif
+
+
+
 
 /* registers definition */
 enum m_can_reg {
@@ -425,6 +440,17 @@
 	m_can_write(cdev, M_CAN_ILE, 0x0);
 }
 
+#if 0
+int m_can_rx_clear(struct net_device *dev)
+{
+        struct m_can_classdev *cdev = netdev_priv(dev);
+        m_can_disable_all_interrupts(cdev);
+        m_can_rx_peripheral(dev);
+
+        return 0;
+}
+EXPORT_SYMBOL_GPL(m_can_rx_clear);
+#endif
 static void m_can_clean(struct net_device *net)
 {
 	struct m_can_classdev *cdev = netdev_priv(net);
@@ -870,26 +896,26 @@
 	return work_done;
 }
 
-static int m_can_rx_peripheral_rx(struct net_device *dev)
+static int m_can_rx_peripheral(struct net_device *dev)
 {
 	struct m_can_classdev *cdev = netdev_priv(dev);
 
-	m_can_rx_handler_rx(dev, 1);
+	m_can_rx_handler(dev, 1);
 
 	m_can_enable_all_interrupts(cdev);
+
 	return 0;
 }
 
-static int m_can_rx_peripheral(struct net_device *dev)
+int m_can_rx_clear(struct net_device *dev)
 {
-	struct m_can_classdev *cdev = netdev_priv(dev);
-
-	m_can_rx_handler(dev, 1);
+        struct m_can_classdev *cdev = netdev_priv(dev);
+        m_can_disable_all_interrupts(cdev);
+        m_can_rx_peripheral(dev);
 
-	m_can_enable_all_interrupts(cdev);
-
-	return 0;
+        return 0;
 }
+EXPORT_SYMBOL_GPL(m_can_rx_clear);
 
 static int m_can_poll(struct napi_struct *napi, int quota)
 {
@@ -906,6 +932,14 @@
 	return work_done;
 }
 
+
+/* Set the "iw_mcan_prop" flag to execute iWave specific change */
+void m_can_set_iw_mcan_prop_flag( void )
+{
+        iw_mcan_prop = true;
+}
+EXPORT_SYMBOL_GPL(m_can_set_iw_mcan_prop_flag);
+
 static void m_can_echo_tx_event(struct net_device *dev)
 {
 	u32 fgi = 0;
@@ -930,6 +964,16 @@
 	stats->tx_packets++;
 }
 
+static int m_can_rx_peripheral_rx(struct net_device *dev)
+{
+	struct m_can_classdev *cdev = netdev_priv(dev);
+
+	m_can_rx_handler_rx(dev, 1);
+
+	m_can_enable_all_interrupts(cdev);
+	return 0;
+}
+
 static irqreturn_t m_can_isr(int irq, void *dev_id)
 {
 	struct net_device *dev = (struct net_device *)dev_id;
@@ -1105,14 +1149,6 @@
 	return 0;
 }
 
-/*
-* Set the "iw_mcan_prop" flag to execute iWave specific changes
-*/
-void m_can_set_iw_mcan_prop_flag( void )
-{
-	iw_mcan_prop = true;
-}
-EXPORT_SYMBOL_GPL(m_can_set_iw_mcan_prop_flag);
 
 /* Configure M_CAN chip:
  * - set rx buffer/fifo element size
@@ -1901,6 +1937,19 @@
 }
 EXPORT_SYMBOL_GPL(m_can_class_unregister);
 
+void m_can_disable_rx_irq(struct m_can_classdev *m_can_dev)
+{
+        iw_ie_reg = m_can_read(m_can_dev, M_CAN_IE);
+        m_can_write(m_can_dev, M_CAN_IE, iw_ie_reg & 0xFFFFFE00);
+}
+EXPORT_SYMBOL_GPL(m_can_disable_rx_irq);
+
+void m_can_enable_rx_irq(struct m_can_classdev *m_can_dev)
+{
+        m_can_write(m_can_dev, M_CAN_IE, iw_ie_reg);
+}
+EXPORT_SYMBOL_GPL(m_can_enable_rx_irq);
+
 MODULE_AUTHOR("Dong Aisheng <b29396@freescale.com>");
 MODULE_AUTHOR("Dan Murphy <dmurphy@ti.com>");
 MODULE_LICENSE("GPL v2");
diff -Naur A/drivers/net/can/m_can/m_can.h B/drivers/net/can/m_can/m_can.h
--- A/drivers/net/can/m_can/m_can.h	2023-07-14 14:50:07.760977844 +0530
+++ B/drivers/net/can/m_can/m_can.h	2023-07-14 14:53:52.760977716 +0530
@@ -28,10 +28,11 @@
 #include <linux/can/dev.h>
 #include <linux/pinctrl/consumer.h>
 
-#ifdef CONFIG_MX6ULL_IWG26I
+//#ifdef CONFIG_MX6ULL_IWG26I
 #include <linux/gpio.h>
 void m_can_set_iw_mcan_prop_flag( void );
-#endif /* CONFIG_MX6ULL_IWG26I */
+//#endif /* CONFIG_MX6ULL_IWG26I 
+
 
 /* m_can lec values */
 enum m_can_lec_type {
@@ -113,4 +114,11 @@
 
 int m_can_class_suspend(struct device *dev);
 int m_can_class_resume(struct device *dev);
+
+int m_can_rx_clear(struct net_device *dev);
+void m_can_disable_rx_irq(struct m_can_classdev *m_can_dev);
+void m_can_enable_rx_irq(struct m_can_classdev *m_can_dev);
+
+
+
 #endif	/* _CAN_M_H_ */
diff -Naur A/drivers/net/can/m_can/tcan4x5x.c B/drivers/net/can/m_can/tcan4x5x.c
--- A/drivers/net/can/m_can/tcan4x5x.c	2023-07-14 14:50:07.760977844 +0530
+++ B/drivers/net/can/m_can/tcan4x5x.c	2023-07-14 14:54:46.640977686 +0530
@@ -83,6 +83,8 @@
 #define TCAN4X5X_MCAN_IR_RF0N BIT(0)
 #define TCAN4X5X_RESET_GPIO 22
 
+
+
 #ifdef CONFIG_MX6ULL_IWG26I
 #define TCAN4X5X_ENABLE_MCAN_INT \
 	(TCAN4X5X_MCAN_IR_TC | TCAN4X5X_MCAN_IR_RF0F | \
@@ -95,6 +97,15 @@
 	 TCAN4X5X_MCAN_IR_RF1F)
 #endif /* CONFIG_MX6ULL_IWG26I */
 
+#define CTRL_REG	0x1018
+#define CTRL_INIT_BIT	BIT(0)
+#define CTRL_CCE_BIT	BIT(1)
+#define RX_FIFO0_CONFIGURATION_REG	0x10A0
+#define RX_FIFO0_WATERMARK_BIT	BIT(24)
+
+
+
+
 #define TCAN4X5X_MRAM_START 0x8000
 #define TCAN4X5X_MCAN_OFFSET 0x1000
 #define TCAN4X5X_MAX_REGISTER 0x8fff
@@ -128,7 +139,7 @@
 #define TCAN4X5X_WD_6_S_TIMER (BIT(28) | BIT(29))
 
 bool iw_tcan_prop = false; /* Flag added for Rugged Telematics Device */
-
+int iw_rxf0_reg_val; /* Variable to store the RX FIFO 0 Configuration register */
 struct tcan4x5x_priv {
 	struct regmap *regmap;
 	struct spi_device *spi;
@@ -599,6 +610,154 @@
 	return 0;
 }
 
+static int tcan4x5x_suspend(struct device *device)
+{
+        int err = 0, ret = 0;
+        struct tcan4x5x_priv *priv = spi_get_drvdata(to_spi_device(device));
+        struct net_device *dev = priv->mcan_dev->net;
+
+        iw_rxf0_reg_val = 0;
+        if (netif_running(dev))
+        {
+                if (device_may_wakeup(device))
+                {
+                        /* 
+                         * For modifying the watermark level for CAN, the INIT and \
+                         * CCE bits should be high. Those are Write protected bits. \
+                         * */
+                        err = regmap_update_bits(priv->regmap, CTRL_REG, CTRL_INIT_BIT, CTRL_INIT_BIT);
+                        if (err)
+                                return err;
+
+                        err = regmap_update_bits(priv->regmap, CTRL_REG, CTRL_CCE_BIT, CTRL_CCE_BIT);
+                        if (err)
+                                return err;
+
+                        /* 
+                         * Reading the current value of RX FIFO 0 register and \
+                         * stores it in iw_rxf0_reg_val to revert it back. \
+                         * */
+                        regmap_read(priv->regmap, RX_FIFO0_CONFIGURATION_REG, &iw_rxf0_reg_val);
+
+                        /* Modify the watermark level as 1 in RX FIFO 0 CONF Register. */
+                        err = iw_rxf0_reg_val & 0x80FFFFFF;
+                        err |= 1 << 24;
+                        ret = regmap_write(priv->regmap, RX_FIFO0_CONFIGURATION_REG, err);
+                        if (ret)
+                                return ret;
+
+                        /* Disable the periodic Watchdog interrupt in RX FIFO 0 CONF Register. */
+                        err = regmap_update_bits(priv->regmap, TCAN4X5X_CONFIG, TCAN4X5X_WATCHDOG_EN, !TCAN4X5X_WATCHDOG_EN);
+                        if (err)
+                                return err;
+
+                        /* Disabling the INIT and CCE bits after changing the Watermark level. */
+                        err = regmap_update_bits(priv->regmap, CTRL_REG, CTRL_CCE_BIT, !CTRL_CCE_BIT);
+                        if (err)
+                                return err;
+
+                        err = regmap_update_bits(priv->regmap, CTRL_REG, CTRL_INIT_BIT, !CTRL_INIT_BIT);
+                        if (err)
+                                return err;
+
+                        /* Enable the IRQ wakeup */
+                        err = enable_irq_wake(priv->mcan_dev->net->irq);
+			                  if(err)
+                                return err;
+
+                        err = m_can_class_suspend(device);
+                          if(err)
+                          return err;
+                }
+        }
+
+        return err;
+}
+static int tcan4x5x_resume(struct device *device)
+{
+        int err = 0;
+        struct tcan4x5x_priv *priv = spi_get_drvdata(to_spi_device(device));
+        struct net_device *dev = priv->mcan_dev->net;
+
+        if (netif_running(dev))
+        {
+                if (device_may_wakeup(device))
+                {
+                        /* Disable the RX interrupts */
+                        m_can_disable_rx_irq(priv->mcan_dev);
+
+                        /* Disable the IRQ wakeup */
+                        err = disable_irq_wake(priv->mcan_dev->net->irq);
+                        if(err)
+                                return err;
+
+                        if (priv->mcan_dev->ops->clear_interrupts)
+                        {
+                                priv->mcan_dev->ops->clear_interrupts(priv->mcan_dev);
+                        }
+                        if (priv->mcan_dev->ops->clear_interrupts_tx)
+                        {
+                                priv->mcan_dev->ops->clear_interrupts_tx(priv->mcan_dev);
+                        }
+
+                        err = m_can_rx_clear(dev);
+                        if(err)
+                                return err;
+
+                        /* 
+                         * For modifying the watermark level for CAN, the INIT and \
+                         * CCE bits should be high. Those are Write protected bits. \
+                         * */
+                        err = regmap_update_bits(priv->regmap, CTRL_REG, CTRL_INIT_BIT, CTRL_INIT_BIT);
+                        if (err)
+                                return err;
+
+                        err = regmap_update_bits(priv->regmap, CTRL_REG, CTRL_CCE_BIT, CTRL_CCE_BIT);
+                        if (err)
+                                return err;
+
+                        err = regmap_update_bits(priv->regmap, TCAN4X5X_CONFIG, WDT_RESET, WDT_RESET_BIT);
+                        if (err)
+                                return err;
+
+                        err = regmap_update_bits(priv->regmap, TCAN4X5X_CONFIG, TCAN4X5X_WATCHDOG_EN, TCAN4X5X_WATCHDOG_EN);
+                        if (err)
+                                return err;
+
+			         /* 
+                         * Reverting back the value of RX FIFO 0 register which was \
+                         * stored in iw_rxf0_reg_val. This will reverts the Watermark \
+                         * value to the previous value. \
+                         * */
+                        err = regmap_write(priv->regmap, RX_FIFO0_CONFIGURATION_REG, iw_rxf0_reg_val);
+                        if (err)
+                                return err;
+
+                        err = regmap_update_bits(priv->regmap, CTRL_REG, CTRL_CCE_BIT, !CTRL_CCE_BIT);
+                        if (err)
+                                return err;
+
+                        err = regmap_update_bits(priv->regmap, CTRL_REG, CTRL_INIT_BIT, !CTRL_INIT_BIT);
+                        if (err)
+                                return err;
+
+                        err = m_can_class_resume(device);
+                        if(err)
+                                return err;
+
+                        /* Enable the RX interrupts */
+                        m_can_enable_rx_irq(priv->mcan_dev);
+                }
+        }
+
+        return err;
+}
+
+static const struct dev_pm_ops tcan4x5x_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(tcan4x5x_suspend, tcan4x5x_resume)
+};
+
+
 static const struct of_device_id tcan4x5x_of_match[] = {
 	{ .compatible = "ti,tcan4x5x", },
 	{ }
@@ -619,6 +778,7 @@
 		.name = DEVICE_NAME,
 		.of_match_table = tcan4x5x_of_match,
 		.pm = NULL,
+		.pm = &tcan4x5x_pm_ops,
 	},
 	.id_table = tcan4x5x_id_table,
 	.probe = tcan4x5x_can_probe,
